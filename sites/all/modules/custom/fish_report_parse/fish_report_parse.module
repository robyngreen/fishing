<?php
/**
 * @file
 * Code for Fish Report Parser module.
 */

// @todo: featurize content types
// @todo: change to drupal form so can submit approval of changes.
// @todo: when a original_report is marked unparsed, all reports from it need to be deleted.

/**
 * Implements hook_menu().
 */
function fish_report_parse_menu() {
  $items = array();
  $items['parse'] = array(
    'title' => 'Fishing Reports Parser',
    'page callback' => 'fish_report_parse_display',
    'access arguments' => array('access content'),
    'type' => MENU_NORMAL_ITEM
  );
  $items['parse/weeks'] = array(
    'title' => 'Fishing Reports Parser - Raw Reports',
    'page callback' => 'fish_report_parse_parse',
    'access arguments' => array('access content'),
    'type' => MENU_NORMAL_ITEM
  );
  $items['parse/reports'] = array(
    'title' => 'Fishing Reports Parser - Individual Reports',
    'page callback' => 'fish_report_parse_reports',
    'access arguments' => array('access content'),
    'type' => MENU_NORMAL_ITEM
  );
  return $items;
}

/**
 * Display function for parser menu callback.
 */
function fish_report_parse_display() {
  fish_report_parse_parse();
  fish_report_parse_reports(); // -- this needs to be a form, and on submit the parent nid is marked 'parsed';
  return 'parsed';
}

function fish_report_parse_parse() {
  $raw_html = drupal_static(__FUNCTION__);
  $reports_url = 'http://www.agfc.com/fishing/Pages/FishingReports.aspx';
  $output = '';

  if (!isset($raw_html)) {
    if ($cache = cache_get('fish_reports_html')) {
      $raw_html = $cache->data;
    }
    else {
      $request = drupal_http_request($reports_url);
      if (!isset($request->error)) {
        $raw_html = $request->data;
        cache_set('fish_reports_html', $raw_html, 'cache');
      }
    }
  }

  $raw_reports = array();
  $pattern = '/href=\"(.*?)\" target=\"\_blank\">(.*?fishing report.*?)<\/a><\/td><td class=\"tableCell\" style=\"width\: .*?px\">WEB/i';
  preg_match_all($pattern, $raw_html, $raw_reports);
  foreach ($raw_reports[2] as $index => $title_string) {
    $title = $raw_reports[2][$index];
    $report_date = fish_report_parse_clean_date($raw_reports[2][$index]);
    $unix_time = strtotime($report_date);
    $url = $raw_reports[1][$index];
    $tmp = array(
      'title' => $title,
      'url' => $url,
      'orig_date' => $report_date,
      'mod_date' => date("Y-m-d H:i:s", $unix_time),
      'unix' => $unix_time,
    );
    fish_report_parse_create_report($tmp);
  }
}

/**
 * Create Report
 *
 * Creates original_report node.
 *
 * @param array $data
 *   Keyed array of data used to build node.
 */
function fish_report_parse_create_report($data) {
  $report = '';
  if ($individual_reports_cache = cache_get('report-' . $data['unix'])) {
    // Fix for bad data.
    $report = $individual_reports_cache->data;
    if ($individual_reports_cache->data == '404') {
      cache_set('report-' . $data['unix'], 'error', 'cache');
      $report = 'error';
    }
  }
  else {
    $individual_report_request = drupal_http_request($data['url']);
    if (!isset($individual_report_request->error)) {
      $report = $individual_report_request->data;
      cache_set('report-' . $data['unix'], $individual_report_request->data, 'cache');
    }
    else {
      cache_set('report-' . $data['unix'], 'error', 'cache');
      $report = 'error';
    }
  }
  $query = new EntityFieldQuery();
  $query->entityCondition('entity_type', 'node')
    ->entityCondition('bundle', 'original_report')
    ->propertyCondition('status', 1)
    ->range(0, 1)
    ->propertyCondition('title', $data['title'], '=')
    ->addMetaData('account', user_load(1));
  $result = $query->execute();
  if (!isset($result['node'])) {
    $node = new stdClass();
    $node->title = $data['title'];
    $node->type = 'original_report';
    node_object_prepare($node);
    $node->language = LANGUAGE_NONE;
    $node->uid = 1;
    $node->body[$node->language][0]['value'] = $report;
    $node->field_date[$node->language][]['value'] = $data['unix'];
    $node->field_url[$node->language][]['url'] = $data['url'];
    node_save($node);
  }
  else {
    dpm('Report ' . $data['title'] . ' exists. Skipping.');
  }
}

/**
 * Cleans Dates.
 *
 * Cleans data from AGF text.
 *
 * @param string $raw_date
 *   Raw date from website.
 *
 * @return string
 *   Cleaned date string.
 */
function fish_report_parse_clean_date($raw_date) {
  // Remove Weekly | Fishing | report from string for date.
  $words = array(
    '/\bweekly\b/i',
    '/\bfishing\b/i',
    '/\breport\b/i',
  );
  $raw_date = preg_replace($words, '', $raw_date);
  $raw_date = preg_replace('/[^A-Za-z0-9\s,]/', '', $raw_date);
  $raw_date = trim($raw_date);
  // Fix typo on ARGF site.
  $raw_date = ($raw_date === 'March, 7, 2012') ? 'March 7, 2012' : $raw_date;
  return $raw_date;
}

/**
 * Loops through unparsed original nodes and creates reports.
 */
function fish_report_parse_reports() {
  $query = new EntityFieldQuery();
  $query->entityCondition('entity_type', 'node')
    ->entityCondition('bundle', 'original_report')
    ->propertyCondition('status', 1)
    ->fieldCondition('field_parsed', 'value', '0', '=')
    ->range(0, 25)
    ->addMetaData('account', user_load(1));
  $result = $query->execute();
  // This could be slow - we just need the body text and nid, not the whole node.
  if (isset($result['node'])) {
    $report_item_nids = array_keys($result['node']);
    $report_items = entity_load('node', $report_item_nids);
  }
  foreach ($report_items as $node) {
    dpm("Report (" . $node->title . ') ' . $node->field_url[LANGUAGE_NONE][0]['url']);
    fish_report_parse_lake($node->body[LANGUAGE_NONE][0]['value']);
    $body = field_get_items('node', $node, 'body');
    $date = field_get_items('node', $node, 'field_date');
    fish_report_parse_individual($node->nid, $body[0]['value'], $date[0]['value']);
    $node->field_parsed[LANGUAGE_NONE][0]['value'] = 1;
    node_save($node);
  }
}

/**
 * Process Lake.
 *
 * Extracts lakes from body of report.
 *
 * @param string $text
 *   Raw report HTML text.
 */
function fish_report_parse_lake($text) {
  $seen_lakes = fish_report_parse_build_term_data('lake');
  $lakes = array();
  if (preg_match_all("/<.*?<strong>.*?<\/div>/i", $text, $lakes)) {
    foreach ($lakes[0] as $lake) {
      $sublake = array();
      $raw_lake = '';
      if (preg_match_all("/<.*?font-size\: 12pt;.*?<\/div>/i", $lake, $sublake)) {
        $raw_lake = $sublake[0][0];
      }
      if (preg_match_all("/<.*?color: (#8f3c1e|rgb\(143, 60, 30\));.*?<\/div>/i", $lake, $sublake)) {
        $raw_lake = $sublake[0][0];
      }
      if ($raw_lake != '') {
        $raw_lake = strip_tags($sublake[0][0]);
        $raw_lake = fish_report_parse_clean($raw_lake);
        $raw_lake = trim($raw_lake);
        $raw_lake = ($raw_lake === 'Greers FerryLake') ? 'Greers Ferry Lake' : $raw_lake;
        if (stripos($raw_lake, 'Just Fishing Guides') === FALSE) {
          if (!in_array($raw_lake, $seen_lakes)) {
            $term = new stdClass();
            $term->name = $raw_lake;
            $term->vid = $vocabulary->vid;
            if (preg_match("/href=('|\")(.*?)('|\")/",$sublake[0][0], $link)) {
              $link[2] = trim($link[2]);
              $request = drupal_http_request($link[2]);
              if (!isset($request->error)) {
                $raw_html = $request->data;
                if (preg_match("/<div id=\"lat.*?display\: none;\">(.*?)<\/div></si",$raw_html,$lat)
                    && preg_match("/<div id=\"long.*?display\: none;\">(.*?)<\/div>/si",$raw_html,$lon)) {
                  $term->field_location[LANGUAGE_NONE][] = array(
                    'lat' => $lat[1],
                    'lon' => $lon[1],
                  );
                }
              }
            }
            taxonomy_term_save($term);
            $seen_lakes[$term->tid] = $raw_lake;
          }
        }
      }
    }
  }
}

/**
 * Process Individual.
 *
 * Processes individual reports.
 *
 * @param int $nid
 *   Node id for overall report.
 * @param string $text
 *   Raw report HTML text.
  * @param int $date
 *   Date of report.
 */
function fish_report_parse_individual($nid, $text, $date) {
  // Each report is a paragraph. Get all html removed, then parse by line.
  $filtered_data = array();
  $all_reports = array();
  $lakes = fish_report_parse_build_term_data('lake');
  $text = fish_report_parse_clean($text);
  preg_match("/<div class=\"e2ma-layout-wrap\">(.*?)<\/div><\/span><\/td>/si", $text, $filtered_data);
  if (empty($filtered_data)) {
    preg_match("/name=\"central\".*?>Central Arkansas(.*?)<\/tbody><\/table>/si", $text, $filtered_data);
  }
  if (empty($filtered_data)) {
    preg_match("/name=\"central-arkansas\".*?>(.*?)e2ma-design-option-footer/si", $text, $filtered_data);
  }
  $all_reports = explode("\n", $filtered_data[1]);
  $all_reports = array_filter($all_reports, 'fish_report_parse_remove_titles');
  $all_reports = array_filter($all_reports);
  $current_lake_tid = '';
  $current_lake_name = '';
  $reports_to_save = array();
  foreach ($all_reports as $report) {
    $report = trim(strip_tags($report));
    if (!empty($report)) {
      if (in_array($report, $lakes)) {
        $current_lake_tid = array_search($report, $lakes);
        $current_lake_name = $report;
      }
      else {
        if (!empty($current_lake_tid)) {
          $report_date = array();
          $save = TRUE;
          if (preg_match('/\(Updated (on |)(.*?)\)/i', $report, $report_date)) {
            $report_date[2] = str_replace('-', '/', $report_date[2]);
            if (strtotime($report_date[2]) >= ($date - (86400 * 6))) {
              $save = TRUE;
            }
            else {
              $save = FALSE;
            }
          }
          if ($save === TRUE) {
            $fishing = fish_report_parse_process_fish($report);
            $reports_to_save[$current_lake_tid][] = array(
              'lake' => $current_lake_name,
              'report' => $report,
              'fishing' => $fishing,
            );
            // Lake Report Text node save.
            $node = new stdClass();
            $node->title = $current_lake_name . ' fishing report for ' . date('Y-m-d', $date);
            $node->type = 'report';
            node_object_prepare($node);
            $node->language = LANGUAGE_NONE;
            $node->uid = 1;
            $node->body[$node->language][0]['value'] = $report;
            $node->field_date[$node->language][]['value'] = $date;
            $node->field_weekly_from[$node->language][]['target_id'] = $nid;
            node_save($node);
            $report_nid = $node->nid;
            foreach ($fishing as $fish_and_condition) {
              // Fishing Report node save.
              $node = new stdClass();
              $node->title = $fish_and_condition['fish_name'] . ' report for ' . $current_lake_name . ' on ' . date('Y-m-d', $date);
              $node->type = 'fishing_report';
              node_object_prepare($node);
              $node->language = LANGUAGE_NONE;
              $node->uid = 1;
              $node->field_date[$node->language][]['value'] = $date;
              $node->field_fish[$node->language][]['tid'] = $fish_and_condition['fish'];
              $node->field_lake[$node->language][]['tid'] = $current_lake_tid;
              $node->field_condition[$node->language][]['tid'] = $fish_and_condition['condition'];
              $node->field_from_report[$node->language][]['target_id'] = $report_nid;
              node_save($node);
            }
          }
        }
      }
    }
  }
  dpm($reports_to_save);
}

/**
 * Process Fish
 *
 * Builds fish condition object.
 *
 * @param string $text
 *   Raw text from website.
 *
 * @return string
 *   Cleans string.
 */
function fish_report_parse_process_fish($report) {
  $fishes = fish_report_parse_build_term_data('fish_type');
  $conditions = fish_report_parse_build_term_data('condition');
  $fishing_report = array();
  foreach ($fishes as $fish_tid => $fish) {
    if (stripos($report, $fish) !== FALSE) {
      foreach ($conditions as $condition_tid => $condition) {
        if (stripos($report, $condition) !== FALSE) {
          if (preg_match("/" . $fish . "(ing|)( fishing| reports|) (are|is|have\sbeen)(\sbiting|\sdone|)(\sfairly|\svery|) " . $condition . "(\s|\.)/i", $report)) {
            $fishing_report[] = array(
              'fish' => $fish_tid,
              'fish_name' => $fish,
              'condition' =>$condition_tid,
              'condition_name' =>$condition,
            );
            // Bait: 
            // "on (wax worms) and (Power Bait) as well as (nightcrawlers)."
            break;
          }
        }
      }
    }
  }
  return $fishing_report;
}

/**
 * Cleans String.
 *
 * Cleans string of bad data.
 *
 * @param string $text
 *   Raw text from website.
 *
 * @return string
 *   Cleans string.
 */
function fish_report_parse_clean($text) {
  $text = str_replace(" ", "", $text);
  return $text;
}

/**
 * Builds taxonomy conditions and stores in memory.
 *
 * @return array
 *   Array of conditions.
 */
function fish_report_parse_build_term_data($vocab_name) {
  $$vocab_name = drupal_static(__FUNCTION__);
  if (!isset($$vocab_name)) {
    $vid = db_select('taxonomy_vocabulary', 'tv')
      ->fields('tv', array('vid'))
      ->condition('machine_name', $vocab_name)
      ->execute()
      ->fetchColumn();
    $options = array();
    if ($vid) {
      $tid = db_select('taxonomy_term_data', 'ttd')
        ->fields('ttd',  array('tid', 'name'))
        ->condition('vid', $vid)
        ->orderBy('weight', 'ASC')
        ->execute()
        ->fetchAllKeyed();
      if ($tid) {
        foreach ($tid as $term_tid => $term_name) {
          ${$vocab_name}[$term_tid] = $term_name;
        }
      }
    }
  }
  return $$vocab_name;
}

/**
 * Remove title.
 *
 * Callback from array_filter to remove strings..
 *
 * @param string $var
 *   Array elements.
 *
 * @return bool
 *   True or False to remove.
 */
function fish_report_parse_remove_titles($var) {
  if (stripos($var, 'font-size: 14pt') !== FALSE || stripos($var, 'Army Corps of Engineers reports the') !== FALSE) {
    return FALSE;
  }
  return TRUE;
}